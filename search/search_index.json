{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction: HPC and job scheduler","text":""},{"location":"#introduction-hpc-and-job-scheduler","title":"Introduction: HPC and job scheduler","text":"<p>Originally from https://genomicsaotearoa.github.io/metagenomics_summer_school/day1/ex2_1_intro_to_scheduler/</p> <p></p>"},{"location":"#defining-high-performance-computing","title":"Defining high-performance computing","text":"<p>The simplest way of defining high-performance computing is by saying that it is the using of high-performance computers (HPC). However, this leads to our next question what is a HPC .</p> <p>HPC</p> <p>A high-performance computer is a network of computers in a cluster that typically share a common purpose and are used to accomplish tasks that might otherwise be too big for any one computer.</p> <p></p> <p>While modern computers can do a lot (and a lot more than their equivalents 10-20 years ago), there are limits to what they can do and the speed at which they are able to do this. One way to overcome these limits is to pool computers together to create a cluster of computers. These pooled resources can then be used to run software that requires more total memory, or need more processors to complete in a reasonable time.</p> <p>One way to do this is to take a group of computers and link them together via a network switch. Consider a case where you have five 4-core computers. By connecting them together, you could run jobs on 20 cores, which could result in your software running faster.</p>"},{"location":"#hpc-architectures","title":"HPC architectures","text":"<p>Most HPC systems follow the ideas described above of taking many computers and linking them via network switches.  described above is:</p> <p></p> <p>What distinguishes a high-performance computer from the computer clusters</p> <ul> <li>The number of computers/nodes </li> <li>The strength of each individual computer/node </li> <li>The network interconnect \u2013 this dictates the communication speed between nodes. The faster this speed is, the more a group of individual nodes will act like a unit.</li> </ul>"},{"location":"#reannz-mahuika-cluster-architecture","title":"REANNZ Mahuika Cluster architecture","text":"<p>REANNZ Mahuika cluster system consists of a number of different node types. The ones visible to researchers are:</p> <ul> <li>Login nodes</li> <li>Compute nodes</li> </ul> Overview of HPC ArchitectureComposition of a nodeIn reality <p> </p> <p></p> <p></p> <p></p> <p></p> <p>Jupyter Terminal</p> <ul> <li>Jupyter terminal should be treated as a login node. .i.e. Just like what we have done so far; use it to develop, test and debug scripts but do not to deploy the production level workflow interactively.</li> </ul> <p>No access to slurm within Jupyter</p> <p>Slurm commands such as <code>srun</code>, <code>sbatch</code>, <code>sacct</code>, and <code>squeue</code> are not available within the JupyterLabs terminal, and instead you need to run these from the login node which from OnDemand is accessed from the OnDemand dashboard top menu \"Clusters\" -&gt; \"NeSI HPC Cluster\"</p>"},{"location":"#from-hardware-to-software","title":"From Hardware to Software","text":"<p>Over 90% HPCs &amp; supercomputers employ Linux as their operating system.  Linux has four essential properties which make it an excellent operating system for the HPCs &amp;  science community:</p> PerformanceFunctionalityFlexibilityPortability <p>Performance of the operating system can be optimized for specific tasks such as running small portable devices or large supercomputers.</p> <p>A number of community-driven scientific applications and libraries have been developed under Linux such as molecular dynamics, linear algebra, and fast-Fourier transforms.</p> <p>The system is flexible enough to allow users to build applications with a wide array of support tools such as compilers, scientific libraries, debuggers, and network monitors.</p> <p>The operating system, utilities, and libraries have been ported to a wide variety of devices including desktops, clusters, supercomputers, mainframes, embedded systems, and smart phones.</p> Supplementary : The Linux operating system is made up of three parts; the kernel, the shell and the software <p>Kernel \u2212 The kernel is the heart of the operating system. It interacts with the hardware and most of the tasks like memory management, task scheduling and file management.</p> <p>Shell \u2212 The shell is the utility that processes your requests (acts as an interface between the user and the kernel). When you type in a command at your terminal, the shell interprets (operating as in interpreter) the command and calls the program that you want. The shell uses standard syntax for all commands. The shell recognizes a limited set of commands, and you must give commands to the shell in a way that it understands: Each shell command consists of a command name, followed by command options (if any are desired) and command arguments (if any are desired). The command name, options, and arguments, are separated by blank space. </p> <ul> <li>An interpreter operates in a simple loop: It accepts a command, interprets the command, executes the command, and then waits for another command. The shell displays a \"prompt,\" to notify you that it is ready to accept your command.  </li> </ul>"},{"location":"#accessing-software-via-modules","title":"Accessing software via modules","text":"<p>On a high-performance computing system, it is quite rare that the software we want to use is available when we log in. It is installed, but we will need to \u201cload\u201d it before it can run.</p> <p>Before we start using individual software packages, however, we should understand the reasoning behind this approach. The three biggest factors are:</p> <ul> <li>software incompatibilities</li> <li>versioning</li> <li>dependencies</li> </ul> <p>One of the workarounds for this issue is Environment modules. A module is a self-contained description of a software package \u2014 it contains the settings required to run a software package and, usually, encodes required dependencies on other software packages.</p> <p>There are a number of different environment module implementations commonly used on HPC systems and the one used in NeSI Mahuika cluster is <code>Lmod</code> where the <code>module</code> command is used to interact with environment modules.</p> <p>Viewing, Accessing and Deploying software with <code>module</code> command</p> <ul> <li>View available modules</li> </ul> <pre><code>#View all modules\n$ module avail\n\n# View all modules which match the keyword in their name\n$ module avail KEYWORD\n\n# View all modules which match the keyword in their name or description\n$ module spider KEYWORD\n</code></pre> <ul> <li> <p>Load a specific program</p> <p>All module names on NeSI Software stack have a version and toolchain/environment suffixes. If none is specified, then the default version of the software is loaded. The default version can be seen with the <code>module avail modulename</code> command (corresponding module name will have <code>(D)</code> suffix)</p> </li> </ul> <pre><code>$ module load Module_Name\n</code></pre> <ul> <li>Unload all current modules</li> </ul> <pre><code>$ module purge\n</code></pre> <p>Please do not use <code>module --force purge</code></p> <ul> <li>Swap a currently loaded module for a different one</li> </ul> <pre><code>$ module switch CURRENT_MODULE DESIRED_MODULE\n</code></pre>"},{"location":"#working-with-job-scheduler","title":"Working with job scheduler","text":"<p>An HPC system might have thousands of nodes and thousands of users. How do we decide who gets what and when? How do we ensure that a task is run with the resources it needs? This job is handled by a special piece of software called the scheduler. On an HPC system, the scheduler manages which jobs run where and when. In brief, scheduler is a </p> <ul> <li>Mechanism to control access by many users to shared computing resources</li> <li>Queuing / scheduling system for users\u2019 jobs</li> <li>Manages the reservation of resources and job execution on these resources </li> <li>Allows users to \u201cfire and forget\u201d large, long calculations or many jobs (\u201cproduction runs\u201d)</li> </ul> <p>Why do we need a scheduler ?</p> <ul> <li>To ensure the machine is utilised as fully as possible</li> <li>To ensure all users get a fair chance to use compute resources (demand usually exceeds supply)</li> <li>To track usage - for accounting and budget control</li> <li>To mediate access to other resources e.g. software licenses</li> </ul> <p>Commonly used schedulers</p> <ul> <li>Slurm</li> <li>PBS , Torque</li> <li>Grid Engine</li> </ul> <p></p> <p>Researchers can not communicate directly to  Compute nodes from the login node. Only way to establish a connection OR send scripts to compute nodes is to use scheduler as the carrier/manager</p>"},{"location":"#life-cycle-of-a-slurm-job","title":"Life cycle of a slurm job","text":"Commonly used Slurm commands Command Function <code>sbatch</code> Submit non-interactive (batch) jobs to the scheduler <code>squeue</code> List jobs in the queue <code>scancel</code> Cancel a job <code>sacct</code> Display accounting data for all jobs and job steps in the Slurm job accounting log or Slurm database <code>srun</code> Slurm directive for parallel computing <code>sinfo</code> Query the current state of nodes <code>salloc</code> Submit interactive jobs to the scheduler <p>About</p>"},{"location":"#anatomy-of-a-slurm-script-and-submitting-first-slurm-job","title":"Anatomy of a slurm script and submitting first slurm job \ud83e\uddd0","text":"<p>As with most other scheduler systems, job submission scripts in Slurm consist of a header section with the shell specification and options to the submission command (<code>sbatch</code> in this case) followed by the body of the script that actually runs the commands you want. In the header section, options to <code>sbatch</code> should be prepended with <code>#SBATCH</code>.</p> <p> </p> <p>Commented lines are ignored by the bash interpreter, but they are not ignored by slurm. The <code>#SBATCH</code> parameters are read by slurm when we submit the job. When the job starts, the bash interpreter will ignore all lines starting with <code>#</code>. This is very similar to the shebang mentioned earlier, when you run your script, the system looks at the <code>#!</code>, then uses the program at the subsequent path to interpret the script, in our case <code>/bin/bash</code> (the program <code>bash</code> found in the /bin directory</p> Slurm variables header use description --job-name <code>#SBATCH --job-name=MyJob</code> The name that will appear when using <code>squeue</code> or <code>sacct</code>. --account <code>#SBATCH --account=nesi12345</code> The account your core hours will be 'charged' to. --time <code>#SBATCH --time=DD-HH:MM:SS</code> Job max walltime. --mem <code>#SBATCH --mem=512MB</code> Memory required per node. --cpus-per-task <code>#SBATCH --cpus-per-task=10</code> Will request 10 logical CPUs per task. --output <code>#SBATCH --output=%j_output.out</code> Path and name of standard output file. <code>%j</code> will be replaced by the job ID. --mail-user <code>#SBATCH --mail-user=me23@gmail.com</code> address to send mail notifications. --mail-type <code>#SBATCH --mail-type=ALL</code> Will send a mail notification at BEGIN END FAIL. <code>#SBATCH --mail-type=TIME_LIMIT_80</code> Will send message at 80% walltime. <p></p> <p>Assigning values to Slurm variables</p> <p></p><p></p> <p></p><p></p> <p></p> <p></p>"}]}